# Middleware

Since Frog is built on top of [Hono](https://hono.dev), Frog supports Hono's middleware pattern.

Middleware works before and after the `.frame` [handler](/reference/frog-frame#handler) by allowing you to manipulate the request and response before and after dispatching respectively. We recommend checking out the Hono [documentation on Middleware](https://hono.dev/guides/middleware) for a more in-depth understanding.

## Overview

There are two ways to inject middleware:

1. Globally, on the [App-level](#app-level).
2. Isolated, on a [Route-level](#route-level).

### App-level

We can inject middleware on the `app` level using the `.use` method. This means middleware will be injected for all routes under `app`.

```tsx twoslash
// @noErrors
/** @jsxImportSource frog/jsx */
// ---cut---
import { Button, Frog } from 'frog'
import { neynar, type NeynarVariables } from 'frog/middlewares'

export const app = new Frog()
// @log:    ↓ 1. Inject middleware onto the app.
  .use(
    neynar({
      apiKey: 'NEYNAR_FROG_FM',
      features: ['interactor', 'cast'],
    }),
  )

// @log: 2. All routes on `app` will inject the middleware.
```

### Route-level

We can inject middleware on a route level:

```tsx twoslash
// @noErrors
/** @jsxImportSource frog/jsx */
// ---cut---
import { Button, Frog } from 'frog'
import { neynar } from 'frog/middlewares'

const neynarMiddleware = neynar({
  apiKey: 'NEYNAR_FROG_FM',
  features: ['interactor', 'cast'],
})

export const app = new Frog()

// @log:                ↓ Inject middleware onto the route.
app.frame('/', neynarMiddleware, (c) => {
  return c.res({
    image: (
      <div style={{ color: 'white', display: 'flex', fontSize: 60 }}>
        {c.var.interactor?.displayName}
      </div>
    ),
  })
})
```

:::tip[Tip]
You can also include more than one middleware on a route!

```tsx
app.frame(
  '/', 
  neynarMiddleware,
  fooMiddleware,
  barMiddleware,
  c => { /* ... */ }
)
```
:::

## Built-in Middlewares

### Neynar

Frog comes with a built-in middleware for [Neynar](https://neynar.com) which allows you to easily integrate Neynar features (such as the interactor of your frame, and frame cast) into Frog context.

```tsx twoslash
/** @jsxImportSource frog/jsx */
// ---cut---
import { Button, Frog } from 'frog'
import { neynar } from 'frog/middlewares'

export const app = new Frog()
// @log:    ↓ 1. Inject `neynar` middleware onto the app.
  .use(
    neynar({
      apiKey: 'NEYNAR_FROG_FM',
      features: ['interactor', 'cast'],
    }),
  )
  .frame('/', (c) => {
// @log:             ↓ 2. Use `c.var` to access Neynar variables!
    const { displayName, followerCount } = c.var.interactor || {}
    console.log('cast: ', c.var.cast)
    console.log('interactor: ', c.var.interactor)
    //                                ^?
    return c.res({
      image: (
        <div
          style={{
            alignItems: 'center',
            color: 'white',
            display: 'flex',
            justifyContent: 'center',
            fontSize: 48,
            height: '100%',
            width: '100%',
          }}
        >
          Greetings {displayName}, you have {followerCount} followers.
        </div>
      ),
    })
  })
```

:::warning
Feel free to use our Neynar API Key: `"NEYNAR_FROG_FM"`.

However, please note that this API Key is for development purposes only – it is prone to rate-limiting.
It is recommended to use your own API Key in production. [See more](https://neynar.com/#get-started).
:::

## Custom Middleware

You can write your own Frog middleware. This is great if you want to share common logic across or frames or if you are developing a SDK for Frog users to hook into their frames.

```tsx twoslash
import { Frog } from 'frog'
// @noErrors
export const app = new Frog()

// Custom logger // [!code focus]
app.use(async (c, next) => { // [!code focus]
  console.log(`[${c.req.method}] ${c.req.url}`) // [!code focus]
  await next() // [!code focus]
}) // [!code focus]

// Add a custom header // [!code focus]
app.use('/foo/*', async (c, next) => { // [!code focus]
  await next() // [!code focus]
  c.header('x-message', 'Only called for `/foo` and `/foo/bar` frames.') // [!code focus]
}) // [!code focus]

app.frame('/', (c) => {/* ... */})

app.frame('/foo', (c) => {/* ... */})

app.frame('/foo/bar', (c) => {/* ... */})
```

### Example: TransactionResponse

You can also write a custom middleware to add additional params to Frog's TransactionResponse (mimics [`Transaction Specs API`](https://warpcast.notion.site/Frame-Transactions-Public-9d9f9f4f527249519a41bd8d16165f73#8235c261091e4499b417e71dd1753e05)).

```tsx twoslash
import { Frog } from 'frog'
// @noErrors
export const app = new Frog()

app.transaction( // [!code focus]
  '/mint', // [!code focus]
  async (c, next) => { // [!code focus]
    await next(); // [!code focus]
    const txParams = await c.res.json(); // [!code focus]
    txParams.attribution = false; // [!code focus]
    c.res = new Response(JSON.stringify(txParams), { // [!code focus]
      headers: { // [!code focus]
        'Content-Type': 'application/json', // [!code focus]
      }, // [!code focus]
    }); // [!code focus]
  }, // [!code focus]
  (c) => {/* ... */} // [!code focus]
); // [!code focus]
```

### Example: Modifying the FrameResponse

You can write a custom middleware to modify the response to add extra [open-frames metadata](https://github.com/open-frames/standard) to fit your needs.

> Since the Frames Spec is still new (launched on 1/26/24) and hasn't hit a stable v1 yet (current vNext), we don't want to introduce additional standards to Frog that might conflict with or diverge from what the Farcaster team and community has planned. In addition, the vast majority of Frame usage at the moment is via Warpcast (and Farcaster) so we want to make sure Frog serves that main audience first.

```tsx twoslash
import { Frog } from 'frog'
// @noErrors
export const app = new Frog()

app.use(async (c, next) => { // [!code focus]
  await next(); // [!code focus]
  const isFrame = c.res.headers.get('content-type')?.includes('html'); // [!code focus]
  if (isFrame) { // [!code focus]
    let html = await c.res.text(); // [!code focus]
    const metaTag = '<meta property="of:accepts:xmtp" content="2024-02-01" />'; // [!code focus]
    html = html.replace(/(<head>)/i, `$1${metaTag}`); // [!code focus]
    c.res = new Response(html, { // [!code focus]
      headers: { // [!code focus]
        'content-type': 'text/html', // [!code focus]
      }, // [!code focus]
    }); // [!code focus]
  } // [!code focus]
}); // [!code focus]
```


## Community Middleware

Middleware is one of the most powerful pieces of Frog. This section showcases community-built middleware that you can use in your Frog apps.

If you've built a middleware for Frog, feel free to [submit a PR](https://github.com/wevm/frog) to add it to this list.

### Airstack Allow List Middleware

The [Allow List Middleware](https://github.com/Airstack-xyz/airstack-frames-sdk/tree/main?tab=readme-ov-file#allow-list-middleware) allows you to build an allow list that only allows certain users to interact a Farcaster Frames. The allow list can be built based on various onchain criterias, including having > X followers, attended certain POAPs, holding certain ERC20/721/1155 tokens, and if a user certain Farcaster users.

To use this middleware, you must first install the [Airstack Frames SDK](https://www.npmjs.com/package/@airstack/frames).

```tsx
import { allowList, TokenBlockchain } from "@airstack/frames"

const app = new Frog()

const allowListMiddleware = allowList({
  allowListCriteria: {
    eventIds: [166577],
    tokens: [
      {
        tokenAddress: "0xe03ef4b9db1a47464de84fb476f9baf493b3e886",
        chain: TokenBlockchain.Zora,
      },
    ],
  },
});

app.use('/', allowListMiddleware)
```

### Airstack Onchain Data Middleware

The [Onchain Data Middleware](https://github.com/Airstack-xyz/airstack-frames-sdk/tree/main?tab=readme-ov-file#onchain-data-middleware) enables you to easily inject various onchain data to your Frames, including Farcaster user details, followings, followers, channels, token balances, POAPs, and more.

To use this middleware, you must first install the [Airstack Frames SDK](https://www.npmjs.com/package/@airstack/frames).

```tsx
import { onchainData, TokenBlockchain } from "@airstack/frames"

const app = new Frog()

const onchainDataMiddleware = onchainData({
  env: "dev",
  features: {
    userDetails: {},
    erc20Mints: {
      chains: [TokenBlockchain.Polygon],
      limit: 1,
    },
  },
});

app.use('/', onchainDataMiddleware)
```

### Pinata FDK Analytics Middleware

The [Frog Analytics Plugin](https://docs.pinata.cloud/farcaster/fdk#frog-analytics-plug-in) allows you to hook into Pinata Frame analytics.

```tsx
import { PinataFDK } from 'pinata-fdk'

const app = new Frog()

const fdk = new PinataFDK({
  pinata_jwt: '<YOUR_PINATA_JWT>',
  pinata_gateway: '<YOUR_PINATA_GATEWAY>'
})

app.use('/', fdk.analyticsMiddleware({
  frameId: 'my-frame-id',
  customId: 'my-custom-id',
}))
```

